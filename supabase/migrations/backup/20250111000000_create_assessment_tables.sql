-- ============================================================================
-- VibrationFit Assessment System
-- ============================================================================
-- This migration creates the complete schema for the vibrational assessment tool.
-- The assessment determines users' "Green Line status" across 12 life categories
-- and is used by VIVA to generate personalized life visions.

-- ============================================================================
-- ENUMS
-- ============================================================================

-- Assessment status enum
CREATE TYPE assessment_status AS ENUM (
  'not_started',
  'in_progress',
  'completed'
);

-- Green Line status enum (alignment level for each category)
CREATE TYPE green_line_status AS ENUM (
  'above',      -- 80%+ (56-70 points) - Above the Green Line
  'transition', -- 60-79% (42-55 points) - In transition
  'below'       -- <60% (14-41 points) - Below the Green Line
);

-- Assessment category enum (matches the 12 life vision categories)
CREATE TYPE assessment_category AS ENUM (
  'money',        -- Money / Wealth
  'health',       -- Health / Vitality
  'family',       -- Family / Parenting
  'romance',      -- Love / Romance
  'social',       -- Social / Friends
  'business',     -- Business / Career
  'fun',          -- Fun / Recreation
  'travel',       -- Travel / Adventure
  'home',         -- Home / Environment
  'possessions',  -- Possessions / Stuff
  'giving',       -- Giving / Legacy
  'spirituality'  -- Spirituality
);

-- ============================================================================
-- MAIN ASSESSMENT TABLE
-- ============================================================================

CREATE TABLE assessment_results (
  -- Primary identification
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- Optional link to profile version (if assessment was part of profile creation)
  profile_version_id UUID REFERENCES user_profiles(id) ON DELETE SET NULL,
  
  -- Assessment status and metadata
  status assessment_status NOT NULL DEFAULT 'not_started',
  total_score INTEGER DEFAULT 0,
  max_possible_score INTEGER DEFAULT 840, -- 12 categories Ã— 70 max points each
  overall_percentage INTEGER DEFAULT 0,
  
  -- Category scores (stored as JSONB for flexibility)
  -- Example: {"money": 56, "health": 42, "family": 68, ...}
  category_scores JSONB DEFAULT '{}',
  
  -- Green Line status per category (stored as JSONB)
  -- Example: {"money": "above", "health": "transition", "family": "above", ...}
  green_line_status JSONB DEFAULT '{}',
  
  -- Timestamps
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Metadata
  assessment_version INTEGER DEFAULT 1, -- Track assessment question version
  notes TEXT, -- Optional notes from user or system
  
  -- Indexes for common queries
  CONSTRAINT valid_scores CHECK (total_score >= 0 AND total_score <= max_possible_score)
);

-- ============================================================================
-- ASSESSMENT RESPONSES TABLE
-- ============================================================================

CREATE TABLE assessment_responses (
  -- Primary identification
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  assessment_id UUID NOT NULL REFERENCES assessment_results(id) ON DELETE CASCADE,
  
  -- Question identification
  question_id TEXT NOT NULL, -- e.g., "money_1", "health_3"
  question_text TEXT NOT NULL,
  category assessment_category NOT NULL,
  
  -- Response data
  response_value INTEGER NOT NULL CHECK (response_value IN (2, 4, 6, 8, 10)),
  response_text TEXT NOT NULL, -- The actual answer text selected
  response_emoji TEXT, -- Optional emoji from the option
  green_line TEXT NOT NULL CHECK (green_line IN ('above', 'neutral', 'below')),
  
  -- Timestamps
  answered_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Ensure one response per question per assessment
  CONSTRAINT unique_assessment_question UNIQUE (assessment_id, question_id)
);

-- ============================================================================
-- ASSESSMENT INSIGHTS TABLE (for VIVA-generated insights)
-- ============================================================================

CREATE TABLE assessment_insights (
  -- Primary identification
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  assessment_id UUID NOT NULL REFERENCES assessment_results(id) ON DELETE CASCADE,
  category assessment_category NOT NULL,
  
  -- Insight data (generated by VIVA)
  insight_type TEXT NOT NULL, -- e.g., "strength", "growth_area", "pattern", "recommendation"
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  confidence_score NUMERIC(3, 2) CHECK (confidence_score >= 0 AND confidence_score <= 1),
  
  -- Supporting data
  supporting_responses JSONB, -- Array of question IDs that support this insight
  
  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- INDEXES
-- ============================================================================

-- Assessment results indexes
CREATE INDEX idx_assessment_results_user_id ON assessment_results(user_id);
CREATE INDEX idx_assessment_results_status ON assessment_results(status);
CREATE INDEX idx_assessment_results_created_at ON assessment_results(created_at DESC);
CREATE INDEX idx_assessment_results_user_status ON assessment_results(user_id, status);
CREATE INDEX idx_assessment_results_profile_version ON assessment_results(profile_version_id);

-- Assessment responses indexes
CREATE INDEX idx_assessment_responses_assessment_id ON assessment_responses(assessment_id);
CREATE INDEX idx_assessment_responses_category ON assessment_responses(category);
CREATE INDEX idx_assessment_responses_question_id ON assessment_responses(question_id);

-- Assessment insights indexes
CREATE INDEX idx_assessment_insights_assessment_id ON assessment_insights(assessment_id);
CREATE INDEX idx_assessment_insights_category ON assessment_insights(category);

-- ============================================================================
-- TRIGGERS
-- ============================================================================

-- Trigger to update updated_at on assessment_results
CREATE OR REPLACE FUNCTION update_assessment_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_assessment_results_updated_at
  BEFORE UPDATE ON assessment_results
  FOR EACH ROW
  EXECUTE FUNCTION update_assessment_updated_at();

-- Trigger to update updated_at on assessment_responses
CREATE TRIGGER update_assessment_responses_updated_at
  BEFORE UPDATE ON assessment_responses
  FOR EACH ROW
  EXECUTE FUNCTION update_assessment_updated_at();

-- Trigger to update updated_at on assessment_insights
CREATE TRIGGER update_assessment_insights_updated_at
  BEFORE UPDATE ON assessment_insights
  FOR EACH ROW
  EXECUTE FUNCTION update_assessment_updated_at();

-- ============================================================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================================================

-- Enable RLS on all tables
ALTER TABLE assessment_results ENABLE ROW LEVEL SECURITY;
ALTER TABLE assessment_responses ENABLE ROW LEVEL SECURITY;
ALTER TABLE assessment_insights ENABLE ROW LEVEL SECURITY;

-- Assessment results policies
CREATE POLICY "Users can view their own assessments"
  ON assessment_results FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own assessments"
  ON assessment_results FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own assessments"
  ON assessment_results FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own assessments"
  ON assessment_results FOR DELETE
  USING (auth.uid() = user_id);

-- Assessment responses policies
CREATE POLICY "Users can view their own assessment responses"
  ON assessment_responses FOR SELECT
  USING (
    assessment_id IN (
      SELECT id FROM assessment_results WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can create their own assessment responses"
  ON assessment_responses FOR INSERT
  WITH CHECK (
    assessment_id IN (
      SELECT id FROM assessment_results WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can update their own assessment responses"
  ON assessment_responses FOR UPDATE
  USING (
    assessment_id IN (
      SELECT id FROM assessment_results WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can delete their own assessment responses"
  ON assessment_responses FOR DELETE
  USING (
    assessment_id IN (
      SELECT id FROM assessment_results WHERE user_id = auth.uid()
    )
  );

-- Assessment insights policies (read-only for users, VIVA writes)
CREATE POLICY "Users can view their own assessment insights"
  ON assessment_insights FOR SELECT
  USING (
    assessment_id IN (
      SELECT id FROM assessment_results WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "System can create assessment insights"
  ON assessment_insights FOR INSERT
  WITH CHECK (true);

-- ============================================================================
-- HELPER FUNCTIONS
-- ============================================================================

-- Function to calculate category score from responses
CREATE OR REPLACE FUNCTION calculate_category_score(
  p_assessment_id UUID,
  p_category assessment_category
)
RETURNS INTEGER AS $$
DECLARE
  v_total_score INTEGER;
BEGIN
  SELECT COALESCE(SUM(response_value), 0)
  INTO v_total_score
  FROM assessment_responses
  WHERE assessment_id = p_assessment_id
    AND category = p_category;
  
  RETURN v_total_score;
END;
$$ LANGUAGE plpgsql;

-- Function to determine Green Line status from score
CREATE OR REPLACE FUNCTION get_green_line_status(p_score INTEGER)
RETURNS green_line_status AS $$
DECLARE
  v_percentage NUMERIC;
BEGIN
  -- Calculate percentage (max score per category is 70 points)
  v_percentage := (p_score::NUMERIC / 70.0) * 100;
  
  -- Determine status
  IF v_percentage >= 80 THEN
    RETURN 'above'::green_line_status;
  ELSIF v_percentage >= 60 THEN
    RETURN 'transition'::green_line_status;
  ELSE
    RETURN 'below'::green_line_status;
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Function to update assessment scores after response changes
CREATE OR REPLACE FUNCTION update_assessment_scores()
RETURNS TRIGGER AS $$
DECLARE
  v_category_score INTEGER;
  v_green_line_status green_line_status;
  v_total_score INTEGER;
  v_category_scores JSONB;
  v_green_line_statuses JSONB;
  v_category_key TEXT;
BEGIN
  -- Get the assessment_id from the new or old row
  IF TG_OP = 'DELETE' THEN
    v_category_key := OLD.assessment_id::TEXT;
  ELSE
    v_category_key := NEW.assessment_id::TEXT;
  END IF;
  
  -- Recalculate all category scores for this assessment
  v_category_scores := '{}'::JSONB;
  v_green_line_statuses := '{}'::JSONB;
  v_total_score := 0;
  
  -- Loop through each category
  FOR v_category_key IN 
    SELECT DISTINCT category::TEXT 
    FROM assessment_responses 
    WHERE assessment_id = COALESCE(NEW.assessment_id, OLD.assessment_id)
  LOOP
    -- Calculate category score
    SELECT calculate_category_score(
      COALESCE(NEW.assessment_id, OLD.assessment_id),
      v_category_key::assessment_category
    ) INTO v_category_score;
    
    -- Get Green Line status
    v_green_line_status := get_green_line_status(v_category_score);
    
    -- Add to JSONB objects
    v_category_scores := v_category_scores || jsonb_build_object(v_category_key, v_category_score);
    v_green_line_statuses := v_green_line_statuses || jsonb_build_object(v_category_key, v_green_line_status);
    v_total_score := v_total_score + v_category_score;
  END LOOP;
  
  -- Update the assessment_results table
  UPDATE assessment_results
  SET 
    category_scores = v_category_scores,
    green_line_status = v_green_line_statuses,
    total_score = v_total_score,
    overall_percentage = ROUND((v_total_score::NUMERIC / max_possible_score::NUMERIC) * 100),
    updated_at = NOW()
  WHERE id = COALESCE(NEW.assessment_id, OLD.assessment_id);
  
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Trigger to auto-update scores when responses change
CREATE TRIGGER update_scores_on_response_change
  AFTER INSERT OR UPDATE OR DELETE ON assessment_responses
  FOR EACH ROW
  EXECUTE FUNCTION update_assessment_scores();

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON TABLE assessment_results IS 'Stores vibrational assessment results across all 12 life categories';
COMMENT ON TABLE assessment_responses IS 'Individual question responses for each assessment';
COMMENT ON TABLE assessment_insights IS 'VIVA-generated insights based on assessment responses';

COMMENT ON COLUMN assessment_results.category_scores IS 'JSONB object with scores for each category (0-70 points each)';
COMMENT ON COLUMN assessment_results.green_line_status IS 'JSONB object with Green Line status for each category (above/transition/below)';
COMMENT ON COLUMN assessment_results.assessment_version IS 'Version of assessment questions used (for tracking changes over time)';

COMMENT ON COLUMN assessment_responses.response_value IS 'Numerical value of the response (2, 4, 6, 8, or 10)';
COMMENT ON COLUMN assessment_responses.green_line IS 'Green Line classification of this specific response (above/neutral/below)';

COMMENT ON FUNCTION calculate_category_score IS 'Calculates total score for a category within an assessment';
COMMENT ON FUNCTION get_green_line_status IS 'Determines Green Line status from a score (0-70 points)';
COMMENT ON FUNCTION update_assessment_scores IS 'Automatically updates assessment totals when responses change';

